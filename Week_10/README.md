一》复杂度：
一个顺序结构的代码，时间复杂度是 O(1)。
二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。
一个简单的 for 循环，时间复杂度是 O(n)。
两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。
两个嵌套的 for 循环，时间复杂度是 O(n²)。

复杂度通常包括时间复杂度和空间复杂度。在具体计算复杂度时需要注意以下几点：
（1）它与具体的常系数无关，O(n) 和 O(2n) 表示的是同样的复杂度。
（2）复杂度相加的时候，选择高者作为结果，也就是说 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。
（3）O(1) 也是表示一个特殊复杂度，即任务与算例个数 n 无关。

二》数组：
由于数组中没有栈和队列那样对于线性表的限制，所以增删查操作变得灵活很多，代码实现的方法也更多样，所以我们要根据实际需求选择适合的方法进行操作。
在实际操作中，我们还要注意根据数组的优缺点合理区分数组和链表的使用。数组定义简单，访问方便，但在数组中所有元素类型必须相同，数组的最大长度必须在定义时给出，数组使用的内存空间必须连续等。
相对而言，数组更适合在数据数量确定，即较少甚至不需要使用新增数据、删除数据操作的场景下使用，这样就有效地规避了数组天然的劣势。在数据对位置敏感的场景下，比如需要高频根据索引位置查找数据时，数组就是个很好的选择了。

三》栈：
栈继承了线性表的优点与不足，是个限制版的线性表。限制的功能是，只允许数据从栈顶进出，这也就是栈后进先出的性质。不管是顺序栈还是链式栈，它们对于数据的新增操作和删除操作的时间复杂度都是 O(1）。而在查找操作中，栈和线性表一样只能通过全局遍历的方式进行，也就是需要 O(n) 的时间复杂度。
栈具有后进先出的特性，当你面对的问题需要高频使用新增、删除操作，且新增和删除操作的数据执行顺序具备后来居上的相反关系时，栈就是个不错的选择。例如，浏览器的前进和后退，括号匹配等问题。栈在代码的编写中有着很广泛的应用，例如，大多数程序运行环境都有的子程序的调用，函数的递归调用等

四》队列：
在时间复杂度上，循环队列和链式队列的新增、删除操作都为 O(1)。而在查找操作中，队列和线性表一样只能通过全局遍历的方式进行，也就是需要 O(n) 的时间复杂度。在空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。
通常情况下，在可以确定队列长度最大值时，建议使用循环队列。无法确定队列长度时，应考虑使用链式队列。队列具有先进先出的特点，很像现实中人们排队买票的场景。在面对数据处理顺序非常敏感的问题时，队列一定是个不错的技术选型。

五》树（Tree）
树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。

	树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树（Quadtree）、多叉树（N-ary Tree）等等。对于一些特殊的树，例如红黑树（Red-Black Tree）、自平衡二叉搜索树（AVL Tree）。

一.前序遍历（Preorder Traversal）
方法：先访问根节点，然后访问左子树，最后访问右子树。在访问左、右子树的时候，同样，先访问子树的根节点，再访问子树根节点的左子树和右子树，这是一个不断递归的过程。
应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。

二.中序遍历（Inorder Traversal）
方法：先访问左子树，然后访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右边。
应用场景：最常见的是二叉搜索树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。

三.后序遍历（Postorder Traversal）
方法：先访问左子树，然后访问右子树，最后访问根节点。
应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。


六》图
被广泛运用的数据结构，很多涉及大数据的问题都得运用到图论的知识。
比如在社交网络里，每个人可以用图的顶点表示，人与人直接的关系可以用图的边表示；再比如，在地图上，要求解从起始点到目的地，如何行驶会更快捷，需要运用图论里的最短路径算法。


七》递归
递归算法是一种调用自身函数的算法（二叉树的许多性质在定义上就满足递归）。
总结：将一个问题的规模变小，然后再利用从小规模问题中得出的结果，结合当前的值或者情况，得出最终的结果。

八》分治  
分治法的核心思想就是“分而治之”。具体来说，它先将一个难以直接解决的大问题，分割成一些可以直接解决的小问题。如果分割后的问题仍然无法直接解决，那么就继续递归地分割，直到每个小问题都可解。
通常而言，这些子问题具备互相独立、形式相同的特点。这样，我们就可以采用同一种解法，递归地去解决这些子问题。最后，再将每个子问题的解合并，就得到了原问题的解。

九》回溯
回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。

解题步骤
一．判断当前情况是否非法，如果非法就立即返回；
二．当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回；
三．当前情况下，遍历所有可能出现的情况并进行下一步的尝试；
四．递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试。

递归和回溯的关系密不可分：
一．递归的基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小然后进行推导的过程。
二．回溯则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程。


十》深度优先搜索（简称为 DFS）
深度优先搜索，从起点出发，从规定的方向中选择其中一个不断地向前走，直到无法继续为止，然后尝试另外一种方向，直到最后走到终点。就像走迷宫一样，尽量往深处走。
DFS 解决的是连通性的问题，即，给定两个点，一个是起始点，一个是终点，判断是不是有一条路径能从起点连接到终点。起点和终点，也可以指的是某种起始状态和最终的状态。问题的要求并不在乎路径是长还是短，只在乎有还是没有。有时候题目也会要求把找到的路径完整的打印出来。

十一》广度优先搜索（简称为 BFS）
广度优先搜索，一般用来解决最短路径的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束。
广度优先的搜索可以同时从起始点和终点开始进行，称之为双端 BFS。这种算法往往可以大大地提高搜索的效率。
举例：在社交应用程序中，两个人之间需要经过多少个朋友的介绍才能互相认识对方。
解法：
1.只从一个方向进行 BFS，有时候这个人认识的朋友特别多，那么会导致搜索起来非常慢；
2.如果另外一方认识的人比较少，从这一方进行搜索，就能极大地减少搜索的次数；
3.每次在决定从哪一边进行搜索的时候，要判断一下哪边认识的人比较少，然后从那边进行搜索。

十二》贪心算法
定义：是一种在每一步选中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。
优点：对于一些问题，非常直观有效。
缺点：1.并不是所有问题都能用它去解决；
2.得到的结果并一定不是正确的，因为这种算法容易过早地做出决定，从而没有办
法达到最优解。

下面通过例题来加深对贪婪算法的认识。例题：0-1 背包问题，能不能运用贪婪算法去解决。
有三种策略：
1.选取价值最大的物品
2.选择重量最轻的物品
3.选取价值/重量比最大的物品

十三》二分查找（Binary Search）
二分搜索（折半搜索）定义：是一种在有序数组中查找某一特定元素的搜索算法。从定义可知，运用二分搜索的前提是数组必须是排好序的。另外，输入并不一定是数组，也有可能是给定一个区间的起始和终止的位置。

优点：时间复杂度是 O(lgn)，非常高效。
因此也称为对数搜索。

缺点：要求待查找的数组或者区间是排好序的。
对数组进行动态的删除和插入操作并完成查找，平均复杂度会变为 O(n)。此时应当考虑采取自平衡的二叉查找树：
1.在 O(nlogn) 的时间内用给定的数据构建出一棵二叉查找树；
2.在 O(logn) 的时间里对目标数据进行搜索；
3.在 O(logn) 的时间里完成删除和插入的操作。

 
因此，当输入的数组或者区间是排好序的，同时又不会经常变动，而要求从里面找出一个满足条件的元素的时候，二分搜索就是最好的选择。
二分搜索一般化的解题思路如下：
1.从已经排好序的数组或区间中取出中间位置的元素，判断该元素是否满足要搜索的条件，如果满足，停止搜索，程序结束。
2.如果正中间的元素不满足条件，则从它两边的区域进行搜索。由于数组是排好序的，可以利用排除法，确定接下来应该从这两个区间中的哪一个去搜索。
3.通过判断，如果发现真正要找的元素在左半区间的话，就继续在左半区间里进行二分搜索。反之，就在右半区间里进行二分搜索。


十四》分治法
分治法的使用必须满足 4 个条件：
A.问题的解决难度与数据规模有关；
B.原问题可被分解；
C.子问题的解可以合并为原问题的解；
D.所有的子问题相互独立。

十五》动态规划：
1. 是数学优化的方法——最优子结构
动态规划是数学优化的方法指，动态规划要解决的都是问题的最优解。而一个问题的最优解是由它的各个子问题的最优解决定的。
由此引出动态规划的第一个重要的属性：最优子结构（Optimal Substructure)。
一般由最优子结构，推导出一个状态转移方程 f(n)，就能很快写出问题的递归实现方法。

2. 是编程的方法——重叠子问题
动态规划是编程的方法指，可以借助编程的技巧去保证每个重叠的子问题只会被求解一次。
引出了动态规划的第二个重要的属性：重叠子问题（Overlapping Sub-problems）。

3. 找重叠子问题
在分析最后一个数 4 的时候，以 3 结尾的最长的上升子序列长度就是 f(5)，因为 3 是第 5 个数。把问题规模缩小 2 个，当前的数变成 101 的时候，找比它小的数，又发现了 3，这个时候又会去重复计算一遍 f(5)，说明该题有重叠的子问题。

Fibonacci数列。
解法：dp[i]=dp[i−1] + dp[i−2]，可以看到，当前值只依赖于前面两个计算好的值。


十六》字典树
字典树的核心思想：
1：Trie 树的核心思想是空间换时间。
2：利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。


十七》并查集
并查集的基本操作：
1：makeSet(s):建立一个新的并查集，其中包含 s 个单元素集合。
2：unionSet(x, y):把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。
3：find(x):找到元素 x 所在的集合的代表，该操作也可以用于判断两个元 素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。

十八》高级搜索
高级搜索有两个特征：一是它是个最优解问题，二是最优的答案深度最小；

十九》红黑树和AVL树
若搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择红黑树。


二十》高级动态规划
动态规划解题的一般思路：
    1. 将原问题分解为子问题
    把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。
    子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。
    2.确定状态
    在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。
    所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。
    整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。
    3.确定一些初始状态（边界状态）的值
    以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。
    4. 确定状态转移方程
     定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。


二十一》字符串算法
一、判断两个字符串是否包含相同的内容
1.巧用数组下标实现，把用字符的ASCII码值当作下标，记录出现的字符，然后对两字符串进行遍历
2.使用键值对TreeMap、HashMap或HashTable进行登记式记录，这个适用于文字等复杂的字符串

二、判断一个字符串是否为另个一字符串的子集
1.数组下标记录实现
2.键值对记录实现

三、去除字符串种出现k次的字符
1.普通实现
2.正则表达式替换实现






